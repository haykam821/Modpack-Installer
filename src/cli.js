const yargs = require("yargs");
const chalk = require("chalk");
const got = require("got");
const fs = require("fs-extra");
const path = require("path");
const nbt = require("prismarine-nbt");

class LogType {
	constructor(prefix, colorer, exit) {
		this.prefix = prefix || "log";
		this.colorer = colorer || chalk.gray;
		this.exit = exit || false;
	}

	format(message) {
		const prefix = this.colorer.bold(this.prefix.toUpperCase() + ":");
		return `${prefix} ${this.colorer(message)}`;
	}
}

/**
 * @type {Object.<LogType>}
 */
const types = {
	critical: new LogType("CRITICAL", chalk.red, true),
	darn: new LogType("   ERROR", chalk.redBright),
	info: new LogType("    INFO", chalk.blue),
	yay: new LogType(" SUCCESS", chalk.green),
};

/**
 * Logs a message to the console.
 * @param {string} typeName The message type.
 * @param {string} msg The message to log.
 * @returns {LogType} The log type that was used for the message.
 */
function log(typeName, msg) {
	const type = types[typeName] || types.darn;
	process.stdout.write(type.format(msg) + "\n");

	if (type.exit) {
		process.exit(0);
	}

	return type;
}

function getModUrl(mod) {
	switch (mod.type) {
		case "forge":
			return `https://minecraft.curseforge.com/projects/${mod.projectID}/files/${mod.fileID}/download`;
		default:
			return mod.url;
	}
}

function ensure(argv, dir) {
	const location = path.join(argv.folder, dir);
	if (argv.clean) {
		return fs.emptyDir(location);
	} else {
		return fs.ensureDir(location);
	}
}

function keyValConfig(obj = {}, header = "Generated by haykam821's modpack installer", timestamp = true) {
	const keyVal = Object.entries(obj).map(entry => {
		return entry[0] + "=" + entry[1];
	}).join("\n");

	const headerThing = header ? `# ${header}\n` : "";
	const timestampThing = timestamp ? `# ${new Date().toUTCString()}\n` : "";

	return headerThing + timestampThing + keyVal;
}

yargs.command("*", "Installs a modpack using a modpack configuration file.", builder => {
	builder.option("config", {
		alias: "c",
		type: "string",
	});
	builder.option("folder", {
		alias: "f",
		description: "The path to the .minecraft folder.",
	});
	builder.option("clean", {
		default: false,
		description: "Removes all content in folders that will be changed by the installation.",
		type: "boolean",
	});
}, async argv => {
	const config = await fs.readJSON(argv.config).catch(() => {
		log("critical", "Could not read the modpack config file.");
	});

	if (!config.pack || !config.pack.format || isNaN(config.pack.format)) {
		log("critical", "This modpack is not in the correct format.");
	}

	if (config.pack.name) {
		log("info", `Installing the ${config.pack.name} modpack.`);
	} else {
		log("info", "Installing the modpack.");
	}

	if (config.servers) {
		const servers = config.servers.map(server => ({
			ip: {
				type: "string",
				value: server.ip,
			},
			name: {
				type: "string",
				value: server.name,
			},
		}));
		const serverNbt = nbt.writeUncompressed({
			name: "servers",
			type: "compound",
			value: {
				servers: {
					type: "list",
					value: {
						type: "compound",
						value: servers,
					},
				},
			},
		});

		fs.writeFile(path.join(argv.folder, "./servers.dat"), serverNbt).then(() => {
			log("info", "The server data has been written.");
		});
	}

	await ensure(argv, "./config/");

	// Splash.properties file
	if (config.splash) {
		await fs.writeFile(path.join(argv.folder, "./config/splash.properties"), keyValConfig(config.splash));
		log("info", "Wrote the splash.properties file.");
	}

	// Mod installation
	await ensure(argv, "./mods/");
	for await (const mod of config.mods) {
		const jar = await got(getModUrl(mod), {
			encoding: null,
		}).catch(() => {
			log("critical", "Could not fetch a mod.");
		});

		const paths = jar.request.gotOptions.pathname.split("/");
		const filename = mod.name || paths[paths.length - 1];

		await fs.writeFile(path.join(argv.folder, "./mods/", filename + ".jar"), jar.body);
		log("info", `Downloaded ${filename}.`);
	}

	log("info", "Finished!");
});

yargs.argv;